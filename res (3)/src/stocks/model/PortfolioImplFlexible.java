package stocks.model;import org.xml.sax.SAXException;import java.io.IOException;import java.time.LocalDate;import java.time.temporal.ChronoUnit;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import javax.xml.parsers.ParserConfigurationException;import stocks.model.dao.DAOAlphaApi;import stocks.model.dao.DAOInterface;import stocks.model.dao.DAOPortfolio;import stocks.model.dao.DAOPortfolioImpl;import stocks.model.dao.IPersistStatergy;import stocks.model.dao.PersistStrategyImpl;import static java.time.temporal.TemporalAdjusters.lastDayOfMonth;import static java.time.temporal.TemporalAdjusters.lastDayOfYear;/** * Represents the implementation of a Flexible Portfolio. It contains all the methods * which is */public class PortfolioImplFlexible implements PortfolioFlexible {  public final Double commission;  private final String portfolioId = "";  private final Map<String, Double> stockCountMap = new HashMap<>();  /**   * Constructor for the class.   */  public PortfolioImplFlexible() {    commission = 1.0;  }  @Override  public void createPortfolio(String portfolioName, String tickerSymbol,                              String date, double quantity, double fee) {    try {      new DAOPortfolioImpl().modifyFlexiblePortfolio(portfolioName,              tickerSymbol, quantity, date, fee);    } catch (Exception e) {      throw new IllegalArgumentException("Error in connecting to the data-store. Try Again");    }  }  @Override  public void sellStockFromPortfolio(String portfolioName, String tickerSymbol, String date,                                     double quantity, double fee) {    try {      new DAOPortfolioImpl().modifyFlexiblePortfolio(portfolioName,              tickerSymbol, -quantity, date, fee);    } catch (Exception e) {      throw new IllegalArgumentException("Error in connecting to the data-store. Try Again");    }  }  @Override  public void purchaseStock(String portfolioName, String tickerSymbol,                            String date, double quantity, double fee) {    try {      new DAOPortfolioImpl().modifyFlexiblePortfolio(portfolioName,              tickerSymbol, quantity, date, fee);    } catch (Exception e) {      throw new IllegalArgumentException("Error in connecting to the data-store. Try Again");    }  }  @Override  public Boolean checkBuyPossible(String id, String askedDate) {    LocalDate date = LocalDate.parse(askedDate);    try {      List<List<String>> list1 = new DAOPortfolioImpl().retrieveTransaction(id);      for (int i = 0; i < list1.size(); ++i) {        String transaction_date = list1.get(i).get(2);        LocalDate transactionDate = LocalDate.parse(transaction_date);        if (date.isBefore(transactionDate)) {          return false;        }      }    } catch (ParserConfigurationException e) {      throw new RuntimeException(e);    } catch (IOException e) {      throw new RuntimeException(e);    } catch (SAXException e) {      throw new RuntimeException(e);    }    return true;  }  @Override  public Boolean checkSellPossible(String id, String tickerSymbol, String localDate,                                   Double sellStockCount) {    if (!(checkBuyPossible(id, localDate))) {      return false;    }    double total = 0.0;    try {      List<List<String>> list1 = new DAOPortfolioImpl().retrieveTransaction(id);      for (int i = 0; i < list1.size(); ++i) {        if (list1.get(i).get(0).equals(tickerSymbol)) {          double count = Double.parseDouble(list1.get(i).get(1));          total += count;        }      }    } catch (ParserConfigurationException e) {      throw new RuntimeException(e);    } catch (IOException e) {      throw new RuntimeException(e);    } catch (SAXException e) {      throw new RuntimeException(e);    }    return total >= sellStockCount;  }  @Override  public String getCompositionOfPortfolio(String id) {    String result = "";    Map<String, Double> mp = new HashMap<>();    try {      List<List<String>> list = new DAOPortfolioImpl().retrieveTransaction(id);      for (int index = 0; index < list.size(); ++index) {        if (mp.containsKey(list.get(index).get(0))) {          double count = mp.get(list.get(index).get(0))                  + Double.parseDouble(list.get(index).get(1));          mp.put(list.get(index).get(0), count);        } else {          mp.put(list.get(index).get(0), Double.valueOf(list.get(index).get(1)));        }      }    } catch (ParserConfigurationException e) {      throw new RuntimeException(e);    } catch (IOException e) {      throw new RuntimeException(e);    } catch (SAXException e) {      throw new RuntimeException(e);    }    result = result + "Portfolio Id: " + id + "\n";    result = result + "Stock" + "    " + "Qty" + "\n";    for (Map.Entry<String, Double> entry : mp.entrySet()) {      result = result + entry.getKey() + " " + entry.getValue() + "\n";    }    return result;  }  @Override  public Double checkCostBasis(String id, String askedDate) {    Double ans = 0.0;    DAOInterface dao;    try {      List<List<String>> list = new DAOPortfolioImpl().retrieveTransaction(id);      LocalDate date = LocalDate.parse(askedDate);      for (int i = 0; i < list.size(); ++i) {        String str = list.get(i).get(2);        Double count = Double.valueOf(list.get(i).get(1));        Double fee = Double.valueOf(list.get(i).get(3));        LocalDate transDate = LocalDate.parse(str);        if (!date.isBefore(transDate) && count > 0) {          dao = new DAOAlphaApi();          String stk = list.get(i).get(0);          Double value = dao.valueOfStockPreDate(stk, transDate);          ans += (value * count) + fee;        }      }    } catch (ParserConfigurationException e) {      throw new RuntimeException(e);    } catch (IOException e) {      throw new RuntimeException(e);    } catch (SAXException e) {      throw new RuntimeException(e);    }    return ans;  }  @Override  public Double getValueOfPortfolio(String id, String askedDate) {    Double ans = 0.0;    DAOInterface dao;    dao = new DAOAlphaApi();    try {      List<List<String>> list = new DAOPortfolioImpl().retrieveTransaction(id);      LocalDate date = LocalDate.parse(askedDate);      for (int i = 0; i < list.size(); ++i) {        String str = list.get(i).get(2);        Double count = Double.valueOf(list.get(i).get(1));        LocalDate transDate = LocalDate.parse(str);        String stk = list.get(i).get(0);        if (!date.isBefore(transDate)) {          Double value = dao.valueOfStockPreDate(stk, date);          ans += value * count;        }      }    } catch (ParserConfigurationException e) {      throw new RuntimeException(e);    } catch (IOException e) {      throw new RuntimeException(e);    } catch (SAXException e) {      throw new RuntimeException(e);    }    return ans;  }  @Override  public Double getValueOfPortfolioInflexible(String id, String askedDate) {    Double ans = 0.0;    DAOInterface dao;    LocalDate date = LocalDate.parse(askedDate);    dao = new DAOAlphaApi();    try {      List<List<String>> list = new DAOPortfolioImpl().retrieveTransaction(id);      for (int i = 0; i < list.size(); ++i) {        String stk = list.get(i).get(0);        Double value = dao.valueOfStockPreDate(stk, date);        Double count = Double.valueOf(list.get(i).get(1));        ans += value * count;      }    } catch (ParserConfigurationException e) {      throw new RuntimeException(e);    } catch (IOException e) {      throw new RuntimeException(e);    } catch (SAXException e) {      throw new RuntimeException(e);    }    return ans;  }  @Override  public boolean isPortfolioExists(String portfolioName) throws          IOException, SAXException, ParserConfigurationException {    return new DAOPortfolioImpl().checkPortfolio(portfolioName);  }  private int divideRange(long x) {    if (x <= 30) {      return 1;    } else if ((x >= 31) && (x <= 210)) {      return 7;    } else if ((x > 210) && (x <= 900)) {      return 30;    } else if ((x > 900) && (x <= 1827)) {      return 60;    } else if (x > 1827) {      return 365;    } else {      return -99999;    }  }  @Override  public String computeGraph(String date1, String date2, String id) {    int diff;    List<List<String>> list = new ArrayList<>();    LocalDate startingDate = LocalDate.parse(date1);    LocalDate endDate = LocalDate.parse(date2);    String s = "";    long days = ChronoUnit.DAYS.between(startingDate, endDate) + 1;    if (days >= 5) {      diff = divideRange(days);      list = computeResult(startingDate, endDate, diff, days, id);      s = drawGraph(id, date1, date2, list);    }    return s;  }  @Override  public void loadStrategy(String portfolioName) throws IOException, SAXException,          ParserConfigurationException {    IPersistStatergy strategy = new PersistStrategyImpl();    DAOPortfolio p = new DAOPortfolioImpl();    List<List<String>> list = new ArrayList<>();    List<String> strategies = p.getStrategies(portfolioName);    for (String s : strategies) {      list.addAll(strategy.loadStrategy(s).getDetails());    }    DAOInterface d = new DAOAlphaApi();    for (List<String> s : list) {      double value = Double.parseDouble(s.get(0));      LocalDate date = LocalDate.parse(s.get(2));      double valueOfStock = d.valueOfStockPreDate(s.get(1), date);      double stkCount = value / valueOfStock;      p.modifyFlexiblePortfolio(portfolioName, s.get(1), stkCount, date.toString(),              Double.parseDouble(s.get(3)));    }  }  @Override  public void loadRegularStrategy(String porfolioName, List<List<String>> data) throws          ParserConfigurationException, IOException, SAXException {    DAOPortfolio p = new DAOPortfolioImpl();    DAOInterface d = new DAOAlphaApi();    double amount = 0.0;    String date = "";    double fee = 0.0;    for (List<String> str : data) {      if (str.size() == 3) {        date = str.get(0);        amount = Double.parseDouble(str.get(1));        fee = Double.parseDouble(str.get(2));        continue;      }      double valueOfStock = d.valueOfStockPreDate(str.get(0), LocalDate.parse(date));      double percentage = Double.parseDouble(str.get(1));      double value = (percentage * amount) / 100;      double stkCount = value / valueOfStock;      p.modifyFlexiblePortfolio(porfolioName, str.get(0), stkCount, date, fee);    }  }  private String drawGraph(String id, String startDate, String endDate, List<List<String>> list) {    double min = Double.MAX_VALUE;    double max = Double.MIN_VALUE;    String result = "";    for (int i = 0; i < list.size(); ++i) {      if (Double.parseDouble(list.get(i).get(1)) < min) {        min = Double.parseDouble(list.get(i).get(1));      }      if (Double.parseDouble(list.get(i).get(1)) > max) {        max = Double.parseDouble(list.get(i).get(1));      }    }    double diff = (max - min) / 49;    List<Double> arr = new ArrayList<>();    for (int i = 0; i < 50; ++i) {      arr.add(i, min + (i * diff));    }    result = result + "Performance of Portfolio " + id +            " from " + startDate + " to " + endDate + "\n";    for (int index = 0; index < list.size(); ++index) {      if (list.get(index).get(1).equals("0.0")) {        result = result + list.get(index).get(0) + ": " + "\n";        continue;      }      Double value = Double.valueOf(next(arr, Double.valueOf(list.get(index).get(1))));      if (value == -1) {        value = Double.valueOf(50);      }      result = result + list.get(index).get(0) + ": ";      for (int i = 1; i <= value; ++i) {        result = result + "*";      }      result = result + "\n";    }    if (min == 0) {      result = result + "Relative Base Amount is $" + 0 + " and one asterisk is $" + diff +              " more than base " + "amount of $" + 0;    } else {      result = result + "Relative Base Amount is $" + (min - diff) +              " and one asterisk is $" + diff +              " more than base " + "amount of $" + (min - diff);    }    return result;  }  private int next(List<Double> arr, Double target) {    int start = 0;    int end = arr.size() - 1;    int ans = -1;    while (start <= end) {      int mid = (start + end) / 2;      // Move to right side if target is      // greater.      if (arr.get(mid) <= target) {        start = mid + 1;      }      // Move left side.      else {        ans = mid;        end = mid - 1;      }    }    return ans;  }  private List<List<String>> computeResult(LocalDate date1, LocalDate date2,                                           int diff, long days, String id) {    List<List<String>> list1 = new ArrayList<>();    List<String> temp = new ArrayList<>();    PortfolioFlexible port = new PortfolioImplFlexible();    LocalDate dateplus = null;    int count = 0;    if ((diff == 7) || (diff == 60)) {      for (long i = 0; i <= days / diff; i = i + 1) {        if (diff == 7) {          dateplus = date1.plusDays(count);          count = count + 7;        } else if (diff == 60) {          LocalDate month = date1.plusMonths(count);          LocalDate end = month.with(lastDayOfMonth());          dateplus = end;          count = count + 2;        }        if (dateplus.isBefore(date2)) {          Double value = port.getValueOfPortfolio(id, dateplus.toString());          temp.add(dateplus.toString());          temp.add(String.valueOf(value));          list1.add(temp);          temp = new ArrayList<>();        }      }    } else if (diff == 30 || (diff < 7) || (diff == 365)) {      LocalDate end = null;      for (long i = 0; i < days / diff; i = i + 1) {        if (diff == 30) {          LocalDate month = date1.plusMonths(count++);          end = month.with(lastDayOfMonth());          dateplus = end;        } else if (diff < 7) {          dateplus = date1.plusDays(i);        } else if (diff == 365) {          LocalDate year = date1.plusYears(count++);          end = year.with(lastDayOfYear());          dateplus = end;        }        if (dateplus.isBefore(date2)) {          Double value = port.getValueOfPortfolio(id, dateplus.toString());          temp.add(dateplus.toString());          temp.add(String.valueOf(value));          list1.add(temp);          temp = new ArrayList<>();        }      }    }    Double value = port.getValueOfPortfolio(id, date2.toString());    temp.add(date2.toString());    temp.add(String.valueOf(value));    list1.add(temp);    return list1;  }  @Override  public double getValue(String date) {    return getValueOfPortfolio(portfolioId, date);  }  @Override  public String getSummary() {    return getCompositionOfPortfolio(portfolioId);  }  @Override  public String getId() {    return portfolioId;  }  @Override  public Map<String, Double> getMap() {    return stockCountMap;  }}